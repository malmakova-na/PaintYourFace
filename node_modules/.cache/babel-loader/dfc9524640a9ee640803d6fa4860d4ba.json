{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TextPath = void 0;\n\nvar Util_1 = require(\"../Util\");\n\nvar Factory_1 = require(\"../Factory\");\n\nvar Shape_1 = require(\"../Shape\");\n\nvar Path_1 = require(\"./Path\");\n\nvar Text_1 = require(\"./Text\");\n\nvar Validators_1 = require(\"../Validators\");\n\nvar Global_1 = require(\"../Global\");\n\nvar EMPTY_STRING = '',\n    NORMAL = 'normal';\n\nfunction _fillFunc(context) {\n  context.fillText(this.partialText, 0, 0);\n}\n\nfunction _strokeFunc(context) {\n  context.strokeText(this.partialText, 0, 0);\n}\n\nvar TextPath = function (_super) {\n  __extends(TextPath, _super);\n\n  function TextPath(config) {\n    var _this = _super.call(this, config) || this;\n\n    _this.dummyCanvas = Util_1.Util.createCanvasElement();\n    _this.dataArray = [];\n    _this.dataArray = Path_1.Path.parsePathData(_this.attrs.data);\n\n    _this.on('dataChange.konva', function () {\n      this.dataArray = Path_1.Path.parsePathData(this.attrs.data);\n\n      this._setTextData();\n    });\n\n    _this.on('textChange.konva alignChange.konva letterSpacingChange.konva kerningFuncChange.konva', _this._setTextData);\n\n    if (config && config['getKerning']) {\n      Util_1.Util.warn('getKerning TextPath API is deprecated. Please use \"kerningFunc\" instead.');\n\n      _this.kerningFunc(config['getKerning']);\n    }\n\n    _this._setTextData();\n\n    return _this;\n  }\n\n  TextPath.prototype._sceneFunc = function (context) {\n    context.setAttr('font', this._getContextFont());\n    context.setAttr('textBaseline', this.textBaseline());\n    context.setAttr('textAlign', 'left');\n    context.save();\n    var textDecoration = this.textDecoration();\n    var fill = this.fill();\n    var fontSize = this.fontSize();\n    var glyphInfo = this.glyphInfo;\n\n    if (textDecoration === 'underline') {\n      context.beginPath();\n    }\n\n    for (var i = 0; i < glyphInfo.length; i++) {\n      context.save();\n      var p0 = glyphInfo[i].p0;\n      context.translate(p0.x, p0.y);\n      context.rotate(glyphInfo[i].rotation);\n      this.partialText = glyphInfo[i].text;\n      context.fillStrokeShape(this);\n\n      if (textDecoration === 'underline') {\n        if (i === 0) {\n          context.moveTo(0, fontSize / 2 + 1);\n        }\n\n        context.lineTo(fontSize, fontSize / 2 + 1);\n      }\n\n      context.restore();\n    }\n\n    if (textDecoration === 'underline') {\n      context.strokeStyle = fill;\n      context.lineWidth = fontSize / 20;\n      context.stroke();\n    }\n\n    context.restore();\n  };\n\n  TextPath.prototype._hitFunc = function (context) {\n    context.beginPath();\n    var glyphInfo = this.glyphInfo;\n\n    if (glyphInfo.length >= 1) {\n      var p0 = glyphInfo[0].p0;\n      context.moveTo(p0.x, p0.y);\n    }\n\n    for (var i = 0; i < glyphInfo.length; i++) {\n      var p1 = glyphInfo[i].p1;\n      context.lineTo(p1.x, p1.y);\n    }\n\n    context.setAttr('lineWidth', this.fontSize());\n    context.setAttr('strokeStyle', this.colorKey);\n    context.stroke();\n  };\n\n  TextPath.prototype.getTextWidth = function () {\n    return this.textWidth;\n  };\n\n  TextPath.prototype.getTextHeight = function () {\n    Util_1.Util.warn('text.getTextHeight() method is deprecated. Use text.height() - for full height and text.fontSize() - for one line height.');\n    return this.textHeight;\n  };\n\n  TextPath.prototype.setText = function (text) {\n    return Text_1.Text.prototype.setText.call(this, text);\n  };\n\n  TextPath.prototype._getContextFont = function () {\n    return Text_1.Text.prototype._getContextFont.call(this);\n  };\n\n  TextPath.prototype._getTextSize = function (text) {\n    var dummyCanvas = this.dummyCanvas;\n\n    var _context = dummyCanvas.getContext('2d');\n\n    _context.save();\n\n    _context.font = this._getContextFont();\n\n    var metrics = _context.measureText(text);\n\n    _context.restore();\n\n    return {\n      width: metrics.width,\n      height: parseInt(this.attrs.fontSize, 10)\n    };\n  };\n\n  TextPath.prototype._setTextData = function () {\n    var that = this;\n\n    var size = this._getTextSize(this.attrs.text);\n\n    var letterSpacing = this.letterSpacing();\n    var align = this.align();\n    var kerningFunc = this.kerningFunc();\n    this.textWidth = size.width;\n    this.textHeight = size.height;\n    var textFullWidth = Math.max(this.textWidth + ((this.attrs.text || '').length - 1) * letterSpacing, 0);\n    this.glyphInfo = [];\n    var fullPathWidth = 0;\n\n    for (var l = 0; l < that.dataArray.length; l++) {\n      if (that.dataArray[l].pathLength > 0) {\n        fullPathWidth += that.dataArray[l].pathLength;\n      }\n    }\n\n    var offset = 0;\n\n    if (align === 'center') {\n      offset = Math.max(0, fullPathWidth / 2 - textFullWidth / 2);\n    }\n\n    if (align === 'right') {\n      offset = Math.max(0, fullPathWidth - textFullWidth);\n    }\n\n    var charArr = Text_1.stringToArray(this.text());\n    var spacesNumber = this.text().split(' ').length - 1;\n    var p0, p1, pathCmd;\n    var pIndex = -1;\n    var currentT = 0;\n\n    var getNextPathSegment = function () {\n      currentT = 0;\n      var pathData = that.dataArray;\n\n      for (var j = pIndex + 1; j < pathData.length; j++) {\n        if (pathData[j].pathLength > 0) {\n          pIndex = j;\n          return pathData[j];\n        } else if (pathData[j].command === 'M') {\n          p0 = {\n            x: pathData[j].points[0],\n            y: pathData[j].points[1]\n          };\n        }\n      }\n\n      return {};\n    };\n\n    var findSegmentToFitCharacter = function (c) {\n      var glyphWidth = that._getTextSize(c).width + letterSpacing;\n\n      if (c === ' ' && align === 'justify') {\n        glyphWidth += (fullPathWidth - textFullWidth) / spacesNumber;\n      }\n\n      var currLen = 0;\n      var attempts = 0;\n      p1 = undefined;\n\n      while (Math.abs(glyphWidth - currLen) / glyphWidth > 0.01 && attempts < 20) {\n        attempts++;\n        var cumulativePathLength = currLen;\n\n        while (pathCmd === undefined) {\n          pathCmd = getNextPathSegment();\n\n          if (pathCmd && cumulativePathLength + pathCmd.pathLength < glyphWidth) {\n            cumulativePathLength += pathCmd.pathLength;\n            pathCmd = undefined;\n          }\n        }\n\n        if (pathCmd === {} || p0 === undefined) {\n          return undefined;\n        }\n\n        var needNewSegment = false;\n\n        switch (pathCmd.command) {\n          case 'L':\n            if (Path_1.Path.getLineLength(p0.x, p0.y, pathCmd.points[0], pathCmd.points[1]) > glyphWidth) {\n              p1 = Path_1.Path.getPointOnLine(glyphWidth, p0.x, p0.y, pathCmd.points[0], pathCmd.points[1], p0.x, p0.y);\n            } else {\n              pathCmd = undefined;\n            }\n\n            break;\n\n          case 'A':\n            var start = pathCmd.points[4];\n            var dTheta = pathCmd.points[5];\n            var end = pathCmd.points[4] + dTheta;\n\n            if (currentT === 0) {\n              currentT = start + 0.00000001;\n            } else if (glyphWidth > currLen) {\n              currentT += Math.PI / 180.0 * dTheta / Math.abs(dTheta);\n            } else {\n              currentT -= Math.PI / 360.0 * dTheta / Math.abs(dTheta);\n            }\n\n            if (dTheta < 0 && currentT < end || dTheta >= 0 && currentT > end) {\n              currentT = end;\n              needNewSegment = true;\n            }\n\n            p1 = Path_1.Path.getPointOnEllipticalArc(pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3], currentT, pathCmd.points[6]);\n            break;\n\n          case 'C':\n            if (currentT === 0) {\n              if (glyphWidth > pathCmd.pathLength) {\n                currentT = 0.00000001;\n              } else {\n                currentT = glyphWidth / pathCmd.pathLength;\n              }\n            } else if (glyphWidth > currLen) {\n              currentT += (glyphWidth - currLen) / pathCmd.pathLength / 2;\n            } else {\n              currentT = Math.max(currentT - (currLen - glyphWidth) / pathCmd.pathLength / 2, 0);\n            }\n\n            if (currentT > 1.0) {\n              currentT = 1.0;\n              needNewSegment = true;\n            }\n\n            p1 = Path_1.Path.getPointOnCubicBezier(currentT, pathCmd.start.x, pathCmd.start.y, pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3], pathCmd.points[4], pathCmd.points[5]);\n            break;\n\n          case 'Q':\n            if (currentT === 0) {\n              currentT = glyphWidth / pathCmd.pathLength;\n            } else if (glyphWidth > currLen) {\n              currentT += (glyphWidth - currLen) / pathCmd.pathLength;\n            } else {\n              currentT -= (currLen - glyphWidth) / pathCmd.pathLength;\n            }\n\n            if (currentT > 1.0) {\n              currentT = 1.0;\n              needNewSegment = true;\n            }\n\n            p1 = Path_1.Path.getPointOnQuadraticBezier(currentT, pathCmd.start.x, pathCmd.start.y, pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3]);\n            break;\n        }\n\n        if (p1 !== undefined) {\n          currLen = Path_1.Path.getLineLength(p0.x, p0.y, p1.x, p1.y);\n        }\n\n        if (needNewSegment) {\n          needNewSegment = false;\n          pathCmd = undefined;\n        }\n      }\n    };\n\n    var testChar = 'C';\n    var glyphWidth = that._getTextSize(testChar).width + letterSpacing;\n    var lettersInOffset = offset / glyphWidth - 1;\n\n    for (var k = 0; k < lettersInOffset; k++) {\n      findSegmentToFitCharacter(testChar);\n\n      if (p0 === undefined || p1 === undefined) {\n        break;\n      }\n\n      p0 = p1;\n    }\n\n    for (var i = 0; i < charArr.length; i++) {\n      findSegmentToFitCharacter(charArr[i]);\n\n      if (p0 === undefined || p1 === undefined) {\n        break;\n      }\n\n      var width = Path_1.Path.getLineLength(p0.x, p0.y, p1.x, p1.y);\n      var kern = 0;\n\n      if (kerningFunc) {\n        try {\n          kern = kerningFunc(charArr[i - 1], charArr[i]) * this.fontSize();\n        } catch (e) {\n          kern = 0;\n        }\n      }\n\n      p0.x += kern;\n      p1.x += kern;\n      this.textWidth += kern;\n      var midpoint = Path_1.Path.getPointOnLine(kern + width / 2.0, p0.x, p0.y, p1.x, p1.y);\n      var rotation = Math.atan2(p1.y - p0.y, p1.x - p0.x);\n      this.glyphInfo.push({\n        transposeX: midpoint.x,\n        transposeY: midpoint.y,\n        text: charArr[i],\n        rotation: rotation,\n        p0: p0,\n        p1: p1\n      });\n      p0 = p1;\n    }\n  };\n\n  TextPath.prototype.getSelfRect = function () {\n    if (!this.glyphInfo.length) {\n      return {\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0\n      };\n    }\n\n    var points = [];\n    this.glyphInfo.forEach(function (info) {\n      points.push(info.p0.x);\n      points.push(info.p0.y);\n      points.push(info.p1.x);\n      points.push(info.p1.y);\n    });\n    var minX = points[0] || 0;\n    var maxX = points[0] || 0;\n    var minY = points[1] || 0;\n    var maxY = points[1] || 0;\n    var x, y;\n\n    for (var i = 0; i < points.length / 2; i++) {\n      x = points[i * 2];\n      y = points[i * 2 + 1];\n      minX = Math.min(minX, x);\n      maxX = Math.max(maxX, x);\n      minY = Math.min(minY, y);\n      maxY = Math.max(maxY, y);\n    }\n\n    var fontSize = this.fontSize();\n    return {\n      x: minX - fontSize / 2,\n      y: minY - fontSize / 2,\n      width: maxX - minX + fontSize,\n      height: maxY - minY + fontSize\n    };\n  };\n\n  return TextPath;\n}(Shape_1.Shape);\n\nexports.TextPath = TextPath;\nTextPath.prototype._fillFunc = _fillFunc;\nTextPath.prototype._strokeFunc = _strokeFunc;\nTextPath.prototype._fillFuncHit = _fillFunc;\nTextPath.prototype._strokeFuncHit = _strokeFunc;\nTextPath.prototype.className = 'TextPath';\nTextPath.prototype._attrsAffectingSize = ['text', 'fontSize', 'data'];\n\nGlobal_1._registerNode(TextPath);\n\nFactory_1.Factory.addGetterSetter(TextPath, 'data');\nFactory_1.Factory.addGetterSetter(TextPath, 'fontFamily', 'Arial');\nFactory_1.Factory.addGetterSetter(TextPath, 'fontSize', 12, Validators_1.getNumberValidator());\nFactory_1.Factory.addGetterSetter(TextPath, 'fontStyle', NORMAL);\nFactory_1.Factory.addGetterSetter(TextPath, 'align', 'left');\nFactory_1.Factory.addGetterSetter(TextPath, 'letterSpacing', 0, Validators_1.getNumberValidator());\nFactory_1.Factory.addGetterSetter(TextPath, 'textBaseline', 'middle');\nFactory_1.Factory.addGetterSetter(TextPath, 'fontVariant', NORMAL);\nFactory_1.Factory.addGetterSetter(TextPath, 'text', EMPTY_STRING);\nFactory_1.Factory.addGetterSetter(TextPath, 'textDecoration', null);\nFactory_1.Factory.addGetterSetter(TextPath, 'kerningFunc', null);\nUtil_1.Collection.mapMethods(TextPath);","map":{"version":3,"sources":["/home/namina/courses/tinkoff/paint-your-face/node_modules/konva/lib/shapes/TextPath.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","__","constructor","create","defineProperty","exports","value","TextPath","Util_1","require","Factory_1","Shape_1","Path_1","Text_1","Validators_1","Global_1","EMPTY_STRING","NORMAL","_fillFunc","context","fillText","partialText","_strokeFunc","strokeText","_super","config","_this","dummyCanvas","Util","createCanvasElement","dataArray","Path","parsePathData","attrs","data","on","_setTextData","warn","kerningFunc","_sceneFunc","setAttr","_getContextFont","textBaseline","save","textDecoration","fill","fontSize","glyphInfo","beginPath","i","length","p0","translate","x","y","rotate","rotation","text","fillStrokeShape","moveTo","lineTo","restore","strokeStyle","lineWidth","stroke","_hitFunc","p1","colorKey","getTextWidth","textWidth","getTextHeight","textHeight","setText","Text","_getTextSize","_context","getContext","font","metrics","measureText","width","height","parseInt","that","size","letterSpacing","align","textFullWidth","Math","max","fullPathWidth","l","pathLength","offset","charArr","stringToArray","spacesNumber","split","pathCmd","pIndex","currentT","getNextPathSegment","pathData","j","command","points","findSegmentToFitCharacter","c","glyphWidth","currLen","attempts","undefined","abs","cumulativePathLength","needNewSegment","getLineLength","getPointOnLine","start","dTheta","end","PI","getPointOnEllipticalArc","getPointOnCubicBezier","getPointOnQuadraticBezier","testChar","lettersInOffset","k","kern","e","midpoint","atan2","push","transposeX","transposeY","getSelfRect","forEach","info","minX","maxX","minY","maxY","min","Shape","_fillFuncHit","_strokeFuncHit","className","_attrsAffectingSize","_registerNode","Factory","addGetterSetter","getNumberValidator","Collection","mapMethods"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TextPath = void 0;\nvar Util_1 = require(\"../Util\");\nvar Factory_1 = require(\"../Factory\");\nvar Shape_1 = require(\"../Shape\");\nvar Path_1 = require(\"./Path\");\nvar Text_1 = require(\"./Text\");\nvar Validators_1 = require(\"../Validators\");\nvar Global_1 = require(\"../Global\");\nvar EMPTY_STRING = '', NORMAL = 'normal';\nfunction _fillFunc(context) {\n    context.fillText(this.partialText, 0, 0);\n}\nfunction _strokeFunc(context) {\n    context.strokeText(this.partialText, 0, 0);\n}\nvar TextPath = (function (_super) {\n    __extends(TextPath, _super);\n    function TextPath(config) {\n        var _this = _super.call(this, config) || this;\n        _this.dummyCanvas = Util_1.Util.createCanvasElement();\n        _this.dataArray = [];\n        _this.dataArray = Path_1.Path.parsePathData(_this.attrs.data);\n        _this.on('dataChange.konva', function () {\n            this.dataArray = Path_1.Path.parsePathData(this.attrs.data);\n            this._setTextData();\n        });\n        _this.on('textChange.konva alignChange.konva letterSpacingChange.konva kerningFuncChange.konva', _this._setTextData);\n        if (config && config['getKerning']) {\n            Util_1.Util.warn('getKerning TextPath API is deprecated. Please use \"kerningFunc\" instead.');\n            _this.kerningFunc(config['getKerning']);\n        }\n        _this._setTextData();\n        return _this;\n    }\n    TextPath.prototype._sceneFunc = function (context) {\n        context.setAttr('font', this._getContextFont());\n        context.setAttr('textBaseline', this.textBaseline());\n        context.setAttr('textAlign', 'left');\n        context.save();\n        var textDecoration = this.textDecoration();\n        var fill = this.fill();\n        var fontSize = this.fontSize();\n        var glyphInfo = this.glyphInfo;\n        if (textDecoration === 'underline') {\n            context.beginPath();\n        }\n        for (var i = 0; i < glyphInfo.length; i++) {\n            context.save();\n            var p0 = glyphInfo[i].p0;\n            context.translate(p0.x, p0.y);\n            context.rotate(glyphInfo[i].rotation);\n            this.partialText = glyphInfo[i].text;\n            context.fillStrokeShape(this);\n            if (textDecoration === 'underline') {\n                if (i === 0) {\n                    context.moveTo(0, fontSize / 2 + 1);\n                }\n                context.lineTo(fontSize, fontSize / 2 + 1);\n            }\n            context.restore();\n        }\n        if (textDecoration === 'underline') {\n            context.strokeStyle = fill;\n            context.lineWidth = fontSize / 20;\n            context.stroke();\n        }\n        context.restore();\n    };\n    TextPath.prototype._hitFunc = function (context) {\n        context.beginPath();\n        var glyphInfo = this.glyphInfo;\n        if (glyphInfo.length >= 1) {\n            var p0 = glyphInfo[0].p0;\n            context.moveTo(p0.x, p0.y);\n        }\n        for (var i = 0; i < glyphInfo.length; i++) {\n            var p1 = glyphInfo[i].p1;\n            context.lineTo(p1.x, p1.y);\n        }\n        context.setAttr('lineWidth', this.fontSize());\n        context.setAttr('strokeStyle', this.colorKey);\n        context.stroke();\n    };\n    TextPath.prototype.getTextWidth = function () {\n        return this.textWidth;\n    };\n    TextPath.prototype.getTextHeight = function () {\n        Util_1.Util.warn('text.getTextHeight() method is deprecated. Use text.height() - for full height and text.fontSize() - for one line height.');\n        return this.textHeight;\n    };\n    TextPath.prototype.setText = function (text) {\n        return Text_1.Text.prototype.setText.call(this, text);\n    };\n    TextPath.prototype._getContextFont = function () {\n        return Text_1.Text.prototype._getContextFont.call(this);\n    };\n    TextPath.prototype._getTextSize = function (text) {\n        var dummyCanvas = this.dummyCanvas;\n        var _context = dummyCanvas.getContext('2d');\n        _context.save();\n        _context.font = this._getContextFont();\n        var metrics = _context.measureText(text);\n        _context.restore();\n        return {\n            width: metrics.width,\n            height: parseInt(this.attrs.fontSize, 10),\n        };\n    };\n    TextPath.prototype._setTextData = function () {\n        var that = this;\n        var size = this._getTextSize(this.attrs.text);\n        var letterSpacing = this.letterSpacing();\n        var align = this.align();\n        var kerningFunc = this.kerningFunc();\n        this.textWidth = size.width;\n        this.textHeight = size.height;\n        var textFullWidth = Math.max(this.textWidth + ((this.attrs.text || '').length - 1) * letterSpacing, 0);\n        this.glyphInfo = [];\n        var fullPathWidth = 0;\n        for (var l = 0; l < that.dataArray.length; l++) {\n            if (that.dataArray[l].pathLength > 0) {\n                fullPathWidth += that.dataArray[l].pathLength;\n            }\n        }\n        var offset = 0;\n        if (align === 'center') {\n            offset = Math.max(0, fullPathWidth / 2 - textFullWidth / 2);\n        }\n        if (align === 'right') {\n            offset = Math.max(0, fullPathWidth - textFullWidth);\n        }\n        var charArr = Text_1.stringToArray(this.text());\n        var spacesNumber = this.text().split(' ').length - 1;\n        var p0, p1, pathCmd;\n        var pIndex = -1;\n        var currentT = 0;\n        var getNextPathSegment = function () {\n            currentT = 0;\n            var pathData = that.dataArray;\n            for (var j = pIndex + 1; j < pathData.length; j++) {\n                if (pathData[j].pathLength > 0) {\n                    pIndex = j;\n                    return pathData[j];\n                }\n                else if (pathData[j].command === 'M') {\n                    p0 = {\n                        x: pathData[j].points[0],\n                        y: pathData[j].points[1],\n                    };\n                }\n            }\n            return {};\n        };\n        var findSegmentToFitCharacter = function (c) {\n            var glyphWidth = that._getTextSize(c).width + letterSpacing;\n            if (c === ' ' && align === 'justify') {\n                glyphWidth += (fullPathWidth - textFullWidth) / spacesNumber;\n            }\n            var currLen = 0;\n            var attempts = 0;\n            p1 = undefined;\n            while (Math.abs(glyphWidth - currLen) / glyphWidth > 0.01 &&\n                attempts < 20) {\n                attempts++;\n                var cumulativePathLength = currLen;\n                while (pathCmd === undefined) {\n                    pathCmd = getNextPathSegment();\n                    if (pathCmd &&\n                        cumulativePathLength + pathCmd.pathLength < glyphWidth) {\n                        cumulativePathLength += pathCmd.pathLength;\n                        pathCmd = undefined;\n                    }\n                }\n                if (pathCmd === {} || p0 === undefined) {\n                    return undefined;\n                }\n                var needNewSegment = false;\n                switch (pathCmd.command) {\n                    case 'L':\n                        if (Path_1.Path.getLineLength(p0.x, p0.y, pathCmd.points[0], pathCmd.points[1]) > glyphWidth) {\n                            p1 = Path_1.Path.getPointOnLine(glyphWidth, p0.x, p0.y, pathCmd.points[0], pathCmd.points[1], p0.x, p0.y);\n                        }\n                        else {\n                            pathCmd = undefined;\n                        }\n                        break;\n                    case 'A':\n                        var start = pathCmd.points[4];\n                        var dTheta = pathCmd.points[5];\n                        var end = pathCmd.points[4] + dTheta;\n                        if (currentT === 0) {\n                            currentT = start + 0.00000001;\n                        }\n                        else if (glyphWidth > currLen) {\n                            currentT += ((Math.PI / 180.0) * dTheta) / Math.abs(dTheta);\n                        }\n                        else {\n                            currentT -= ((Math.PI / 360.0) * dTheta) / Math.abs(dTheta);\n                        }\n                        if ((dTheta < 0 && currentT < end) ||\n                            (dTheta >= 0 && currentT > end)) {\n                            currentT = end;\n                            needNewSegment = true;\n                        }\n                        p1 = Path_1.Path.getPointOnEllipticalArc(pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3], currentT, pathCmd.points[6]);\n                        break;\n                    case 'C':\n                        if (currentT === 0) {\n                            if (glyphWidth > pathCmd.pathLength) {\n                                currentT = 0.00000001;\n                            }\n                            else {\n                                currentT = glyphWidth / pathCmd.pathLength;\n                            }\n                        }\n                        else if (glyphWidth > currLen) {\n                            currentT += (glyphWidth - currLen) / pathCmd.pathLength / 2;\n                        }\n                        else {\n                            currentT = Math.max(currentT - (currLen - glyphWidth) / pathCmd.pathLength / 2, 0);\n                        }\n                        if (currentT > 1.0) {\n                            currentT = 1.0;\n                            needNewSegment = true;\n                        }\n                        p1 = Path_1.Path.getPointOnCubicBezier(currentT, pathCmd.start.x, pathCmd.start.y, pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3], pathCmd.points[4], pathCmd.points[5]);\n                        break;\n                    case 'Q':\n                        if (currentT === 0) {\n                            currentT = glyphWidth / pathCmd.pathLength;\n                        }\n                        else if (glyphWidth > currLen) {\n                            currentT += (glyphWidth - currLen) / pathCmd.pathLength;\n                        }\n                        else {\n                            currentT -= (currLen - glyphWidth) / pathCmd.pathLength;\n                        }\n                        if (currentT > 1.0) {\n                            currentT = 1.0;\n                            needNewSegment = true;\n                        }\n                        p1 = Path_1.Path.getPointOnQuadraticBezier(currentT, pathCmd.start.x, pathCmd.start.y, pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3]);\n                        break;\n                }\n                if (p1 !== undefined) {\n                    currLen = Path_1.Path.getLineLength(p0.x, p0.y, p1.x, p1.y);\n                }\n                if (needNewSegment) {\n                    needNewSegment = false;\n                    pathCmd = undefined;\n                }\n            }\n        };\n        var testChar = 'C';\n        var glyphWidth = that._getTextSize(testChar).width + letterSpacing;\n        var lettersInOffset = offset / glyphWidth - 1;\n        for (var k = 0; k < lettersInOffset; k++) {\n            findSegmentToFitCharacter(testChar);\n            if (p0 === undefined || p1 === undefined) {\n                break;\n            }\n            p0 = p1;\n        }\n        for (var i = 0; i < charArr.length; i++) {\n            findSegmentToFitCharacter(charArr[i]);\n            if (p0 === undefined || p1 === undefined) {\n                break;\n            }\n            var width = Path_1.Path.getLineLength(p0.x, p0.y, p1.x, p1.y);\n            var kern = 0;\n            if (kerningFunc) {\n                try {\n                    kern = kerningFunc(charArr[i - 1], charArr[i]) * this.fontSize();\n                }\n                catch (e) {\n                    kern = 0;\n                }\n            }\n            p0.x += kern;\n            p1.x += kern;\n            this.textWidth += kern;\n            var midpoint = Path_1.Path.getPointOnLine(kern + width / 2.0, p0.x, p0.y, p1.x, p1.y);\n            var rotation = Math.atan2(p1.y - p0.y, p1.x - p0.x);\n            this.glyphInfo.push({\n                transposeX: midpoint.x,\n                transposeY: midpoint.y,\n                text: charArr[i],\n                rotation: rotation,\n                p0: p0,\n                p1: p1,\n            });\n            p0 = p1;\n        }\n    };\n    TextPath.prototype.getSelfRect = function () {\n        if (!this.glyphInfo.length) {\n            return {\n                x: 0,\n                y: 0,\n                width: 0,\n                height: 0,\n            };\n        }\n        var points = [];\n        this.glyphInfo.forEach(function (info) {\n            points.push(info.p0.x);\n            points.push(info.p0.y);\n            points.push(info.p1.x);\n            points.push(info.p1.y);\n        });\n        var minX = points[0] || 0;\n        var maxX = points[0] || 0;\n        var minY = points[1] || 0;\n        var maxY = points[1] || 0;\n        var x, y;\n        for (var i = 0; i < points.length / 2; i++) {\n            x = points[i * 2];\n            y = points[i * 2 + 1];\n            minX = Math.min(minX, x);\n            maxX = Math.max(maxX, x);\n            minY = Math.min(minY, y);\n            maxY = Math.max(maxY, y);\n        }\n        var fontSize = this.fontSize();\n        return {\n            x: minX - fontSize / 2,\n            y: minY - fontSize / 2,\n            width: maxX - minX + fontSize,\n            height: maxY - minY + fontSize,\n        };\n    };\n    return TextPath;\n}(Shape_1.Shape));\nexports.TextPath = TextPath;\nTextPath.prototype._fillFunc = _fillFunc;\nTextPath.prototype._strokeFunc = _strokeFunc;\nTextPath.prototype._fillFuncHit = _fillFunc;\nTextPath.prototype._strokeFuncHit = _strokeFunc;\nTextPath.prototype.className = 'TextPath';\nTextPath.prototype._attrsAffectingSize = ['text', 'fontSize', 'data'];\nGlobal_1._registerNode(TextPath);\nFactory_1.Factory.addGetterSetter(TextPath, 'data');\nFactory_1.Factory.addGetterSetter(TextPath, 'fontFamily', 'Arial');\nFactory_1.Factory.addGetterSetter(TextPath, 'fontSize', 12, Validators_1.getNumberValidator());\nFactory_1.Factory.addGetterSetter(TextPath, 'fontStyle', NORMAL);\nFactory_1.Factory.addGetterSetter(TextPath, 'align', 'left');\nFactory_1.Factory.addGetterSetter(TextPath, 'letterSpacing', 0, Validators_1.getNumberValidator());\nFactory_1.Factory.addGetterSetter(TextPath, 'textBaseline', 'middle');\nFactory_1.Factory.addGetterSetter(TextPath, 'fontVariant', NORMAL);\nFactory_1.Factory.addGetterSetter(TextPath, 'text', EMPTY_STRING);\nFactory_1.Factory.addGetterSetter(TextPath, 'textDecoration', null);\nFactory_1.Factory.addGetterSetter(TextPath, 'kerningFunc', null);\nUtil_1.Collection.mapMethods(TextPath);\n"]},"metadata":{},"sourceType":"script"}